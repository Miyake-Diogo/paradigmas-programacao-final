{-# LANGUAGE OverloadedLabels  #-}
{-# LANGUAGE OverloadedStrings #-}
module Main where
import Options.Applicative
import Data.Semigroup ((<>))


-- quickSort
quickSort::(Ord a) => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = quickSort (filter (\y -> y < x ) xs) ++ [x] ++  quickSort (filter (\y -> y >= x ) xs)


-- mergeSort TopDown
merge::(Ord a) => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys) = if x <= y 
                        then x:merge xs (y:ys)
                        else y:merge (x:xs) ys

mergeSortTopDown::(Ord a) => [a] -> [a]
mergeSortTopDown xs = let n = length xs
              in  
                if n <= 1 
                then xs
                else merge (mergeSortTopDown (take (n `div` 2) xs)) (mergeSortTopDown (drop (n `div` 2) xs))
-- Bottom Up 
-- reference: https://riptutorial.com/haskell/example/7552/merge-sort
mergeSortBottomUp::(Ord a) => [a] -> [a]
mergeSortBottomUp [] = []
mergeSortBottomUp xs = go [[x] | x <- xs]
    where
    go [a] = a
    go xs = go (pairs xs)
    pairs (a:b:t) = merge a b : pairs t
    pairs t = t

-- selection Sort

minimunElement:: Ord b => [b]-> b
minimunElement [x] = x
minimunElement (x:y:xs) = minimunElement ((if x <= y then x else y):xs)

removeItem::(Eq a) => a -> [a] -> [a]
removeItem _ [] = []
removeItem x (y:ys) | x == y    = removeItem x ys
                    | otherwise = y : removeItem x ys

selectionSort::(Ord a) => [a] -> [a]
selectionSort [] = []
selectionSort xs = (x:selectionSort (removeItem x xs))
          where 
             x = minimunElement xs

---- ARGUMENTS PARSER

data SortAlgorithms = SortAlgorithms
  { name :: String }

-- algo :: Parser SortAlgorithms
-- algo = SortAlgorithms
--       <$> strOption
--           ( long "selectionSort"
--          <> short "ss"
--          <> metavar "LIST"
--          <> help "selection sort algorithm" )
--       <$> strOption
--           ( long "mergeSortB"
--          <> short "msb"
--          <> metavar "LIST"
--          <> help "merge sort bottom up algorithm" )
--       <$> strOption
--           ( long "mergeSortT"
--          <> short "mst"
--          <> metavar "LIST"
--          <> help "merge sort top down algorithm" )
--       <$> strOption
--           ( long "quickSort"
--          <> short "qs"
--          <> metavar "LIST"
--          <> help "quick sort algorithm" )


main :: IO ()
-- main = do
--   putStrLn $ "Select a Sorting Algotrithm to run..."
--   putStrLn $ show (selectionSort [11,3,25,76,99,0])
  
-- main = running =<< execParser opts
--   where
--     opts = info (SortAlgorithms <**> helper)
--       ( fullDesc
--      <> progDesc "Run a sorting algorithms pass a list after arguments with number as space char"
--      <> header "A sorting algorithms" )
main = do
  let ver = "sample"
  args <-
    execParser $
    info
   ( SortAlgorithms
      <$> strOption
          ( long "selectionSort"
         <> metavar "LIST"
         <> help "selection sort algorithm" )
       <* strOption
          ( long "mergeSortB"
         <> metavar "LIST"
         <> help "merge sort bottom up algorithm" )
       <* strOption
          ( long "mergeSortT"
         <> metavar "LIST"
         <> help "merge sort top down algorithm" )
       <* strOption
          ( long "quickSort"
         <> metavar "LIST"
         <> help "quick sort algorithm" )
       <*
       abortOption ShowHelpText (long "help" <>
                                 short 'h' <>
                                 help "Display this message."))
      (progDesc "Very powerful tool." <> fullDesc)
   putStrLn args 
-- running :: SortAlgorithms -> IO ()
-- running (SortAlgorithms h) = if SortAlgorithms == "selection_sort" then putStrLn $ show (selectionSort (map read $ words h))
--                                      else  if SortAlgorithms == "merge_sortT" then putStrLn $ show (mergeSortTopDown (map read $ words h))
--                                      else  if SortAlgorithms == "merge_sortB" then putStrLn $ show (mergeSortBottomUp (map read $ words h))
--                                      else  if SortAlgorithms == "quick_sort" then putStrLn $ show (quickSort (map read $ words h))
--                                      else putStrLn "Please select an algorithm" ++ ver
-- running _ = return ()